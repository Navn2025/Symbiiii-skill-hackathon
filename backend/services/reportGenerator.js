class ReportGenerator
{
    generateReport({code, language, executionResult, analysis})
    {
        const timestamp=new Date().toISOString();
        const filename=`code_report_${Date.now()}.md`;
        const markdown=this.buildMarkdownReport({code, language, executionResult, analysis, timestamp});
        return {markdown, filename, timestamp};
    }

    buildMarkdownReport({code, language, executionResult, analysis, timestamp})
    {
        const date=new Date(timestamp);
        const formattedDate=date.toLocaleString('en-US', {year: 'numeric', month: 'long', day: 'numeric', hour: '2-digit', minute: '2-digit', second: '2-digit'});
        let report=`# Code Analysis Report\n\n**Generated:** ${formattedDate}  \n**Language:** ${language}  \n**Powered by:** Groq AI  \n\n---\n\n## Summary\n\n${this.generateSummarySection(executionResult, analysis)}\n\n---\n\n## Your Code\n\n\`\`\`${language}\n${code}\n\`\`\`\n\n---\n\n`;
        if (executionResult) report+=this.generateExecutionSection(executionResult);
        if (analysis?.mistakes?.length>0) report+=this.generateMistakesSection(analysis.mistakes, language);
        if (analysis?.suggestions?.length>0) report+=this.generateSuggestionsSection(analysis.suggestions, language);
        if (analysis) report+=this.generateQualitySection(analysis);
        if (analysis?.complexity) report+=this.generateComplexitySection(analysis.complexity);
        if (analysis?.bestPractices?.length>0) report+=this.generateBestPracticesSection(analysis.bestPractices);
        if (analysis?.improvements?.length>0) report+=this.generateImprovementsSection(analysis.improvements);
        report+=`\n---\n\n## Next Steps\n\n1. Review and fix any critical issues identified\n2. Apply suggested improvements\n3. Test your code with different inputs\n4. Keep learning and practicing!\n\n---\n\n*Report generated by Coding Platform with Groq AI*\n*${formattedDate}*\n`;
        return report;
    }

    generateSummarySection(executionResult, analysis)
    {
        const status=executionResult&&!executionResult.hasError? 'Success':'Failed';
        const score=analysis?.qualityScore||'N/A';
        return `| Metric | Value |\n|--------|-------|\n| **Execution Status** | ${status} |\n| **Quality Score** | ${score}/100 |\n| **Issues Found** | ${analysis?.mistakes?.length||0} |\n| **Suggestions** | ${analysis?.suggestions?.length||0} |\n${executionResult? `| **Execution Time** | ${executionResult.executionTime}ms |`:''}\n`;
    }

    generateExecutionSection(executionResult)
    {
        let section=`## Execution Results\n\n`;
        if (executionResult.hasError) {section+=`### Errors\n\n\`\`\`\n${executionResult.errors}\n\`\`\`\n\n`;}
        else {section+=`### Output\n\n${executionResult.output? `\`\`\`\n${executionResult.output}\n\`\`\`\n\n`:'*No output produced*\n\n'}`;}
        section+=`**Execution Time:** ${executionResult.executionTime}ms\n\n---\n\n`;
        return section;
    }

    generateMistakesSection(mistakes, language)
    {
        let section=`## Issues Identified\n\n`;
        mistakes.forEach((mistake, i) =>
        {
            section+=`### ${i+1}. ${mistake.type} Error${mistake.line? ` (Line ${mistake.line})`:''}\n\n`;
            section+=`**Severity:** ${mistake.severity?.toUpperCase()}  \n**Issue:** ${mistake.message}\n\n`;
            if (mistake.explanation) section+=`**Explanation:**  \n${mistake.explanation}\n\n`;
            if (mistake.fix) section+=`**Suggested Fix:**\n\n\`\`\`${language}\n${mistake.fix}\n\`\`\`\n\n`;
            section+=`---\n\n`;
        });
        return section;
    }

    generateSuggestionsSection(suggestions, language)
    {
        let section=`## Improvement Suggestions\n\n`;
        suggestions.forEach((s, i) =>
        {
            section+=`### ${i+1}. ${s.title}\n\n**Category:** ${s.category}\n\n${s.description}\n\n`;
            if (s.codeExample) section+=`**Example:**\n\n\`\`\`${language}\n${s.codeExample}\n\`\`\`\n\n`;
            section+=`---\n\n`;
        });
        return section;
    }

    generateQualitySection(analysis)
    {
        const score=analysis.qualityScore||0;
        const filled=Math.floor(score/5);
        const bar=`[${'█'.repeat(filled)}${'░'.repeat(20-filled)}] ${score}%`;
        return `## Code Quality Assessment\n\n**Overall Score:** ${score}/100\n\n${bar}\n\n`;
    }

    generateComplexitySection(complexity)
    {
        let section=`## Complexity Analysis\n\n| Metric | Value |\n|--------|-------|\n| **Time Complexity** | ${complexity.timeComplexity} |\n| **Space Complexity** | ${complexity.spaceComplexity} |\n\n`;
        if (complexity.explanation) section+=`**Analysis:**  \n${complexity.explanation}\n\n`;
        section+=`---\n\n`;
        return section;
    }

    generateBestPracticesSection(bestPractices)
    {
        let section=`## Best Practices Checklist\n\n`;
        bestPractices.forEach(p => {section+=`${p.applied? '✅':'❌'} **${p.title}**  \n   ${p.description}\n\n`;});
        section+=`---\n\n`;
        return section;
    }

    generateImprovementsSection(improvements)
    {
        let section=`## Action Items\n\n`;
        improvements.forEach((imp, i) => {section+=`${i+1}. ${imp}\n`;});
        section+=`\n---\n\n`;
        return section;
    }
}

export default new ReportGenerator();
